---
title: ZUC ç¥–å†²ä¹‹åºåˆ—å¯†ç ç®—æ³•
icon: stream
order: 4
author: mumu
date: 2025-11-23
category:
  - å›½å¯†ç®—æ³•
  - æµå¯†ç 
tag:
  - ZUC
  - ç¥–å†²ä¹‹
  - æµå¯†ç 
  - LTEåŠ å¯†
---

# ZUC ç¥–å†²ä¹‹åºåˆ—å¯†ç ç®—æ³•

## æ¦‚è¿°

ZUCï¼ˆç¥–å†²ä¹‹ç®—æ³•ï¼‰æ˜¯ä¸­å›½è‡ªä¸»è®¾è®¡çš„æµå¯†ç ç®—æ³•ï¼Œä»¥ä¸­å›½å¤ä»£æ•°å­¦å®¶ç¥–å†²ä¹‹å‘½åã€‚ZUC ç®—æ³•è¢« 3GPP ç»„ç»‡é‡‡çº³ä¸º 4G LTE å›½é™…æ ‡å‡†çš„ç¬¬ä¸‰ç»„åŠ å¯†å’Œå®Œæ•´æ€§ç®—æ³•ï¼ˆ128-EEA3 å’Œ 128-EIA3ï¼‰ï¼Œå¹¿æ³›åº”ç”¨äºç§»åŠ¨é€šä¿¡é¢†åŸŸã€‚

### æ ‡å‡†ä¾æ®

- **GM/T 0001-2012**: ZUC åºåˆ—å¯†ç ç®—æ³•
- **3GPP TS 35.221**: ZUC-128 åŠ å¯†ç®—æ³•ï¼ˆ128-EEA3ï¼‰
- **3GPP TS 35.222**: ZUC-128 å®Œæ•´æ€§ç®—æ³•ï¼ˆ128-EIA3ï¼‰

### ä¸»è¦ç‰¹æ€§

- **å›½é™…æ ‡å‡†**: è¢« 3GPP é‡‡çº³ä¸º LTE å›½é™…æ ‡å‡†ï¼Œåº”ç”¨äºå…¨çƒç§»åŠ¨é€šä¿¡ç½‘ç»œ
- **æµå¯†ç è®¾è®¡**: åºåˆ—å¯†ç è®¾è®¡ï¼Œé€‚åˆå®æ—¶æµæ•°æ®åŠ å¯†
- **åŒåŠŸèƒ½**: æ”¯æŒåŠ å¯†ï¼ˆEEA3ï¼‰å’Œå®Œæ•´æ€§ä¿æŠ¤ï¼ˆEIA3ï¼‰
- **ç§»åŠ¨ä¼˜åŒ–**: ä¸“ä¸ºç§»åŠ¨é€šä¿¡åœºæ™¯è®¾è®¡å’Œä¼˜åŒ–
- **å®‰å…¨æ€§**: 128 ä½å¯†é’¥ï¼ŒæŠ—å·²çŸ¥æ”»å‡»æ–¹å¼

### æ€§èƒ½ä¸å®‰å…¨æƒè¡¡

ZUC ä½œä¸ºæµå¯†ç ï¼Œä¸åˆ†ç»„å¯†ç ï¼ˆå¦‚ SM4ã€AESï¼‰æœ‰ä¸åŒçš„ç‰¹ç‚¹ï¼š
- **åŠ å¯†é€Ÿåº¦**: æµå¯†ç é€šå¸¸æ¯”åˆ†ç»„å¯†ç å¿«ï¼Œå› ä¸ºä¸éœ€è¦åˆ†å—å’Œå¡«å……
- **å®æ—¶æ€§**: é€‚åˆæµå¼æ•°æ®åŠ å¯†ï¼Œæ— éœ€ç­‰å¾…å®Œæ•´æ•°æ®å—
- **ç¡¬ä»¶æ”¯æŒ**: 
  - åœ¨æ”¯æŒ ZUC ç¡¬ä»¶åŠ é€Ÿçš„å›½äº§èŠ¯ç‰‡ä¸Šæ€§èƒ½ä¼˜å¼‚
  - åœ¨é€šç”¨èŠ¯ç‰‡ä¸Šä¸ºçº¯è½¯ä»¶å®ç°ï¼Œæ€§èƒ½å–å†³äºå®ç°è´¨é‡
- **åº”ç”¨åœºæ™¯**: ä¸»è¦ç”¨äºç§»åŠ¨é€šä¿¡ï¼Œä¸€èˆ¬åº”ç”¨ä¸­ SM4 æ›´å¸¸ç”¨

::: tip æµå¯†ç  vs åˆ†ç»„å¯†ç 
æµå¯†ç ï¼ˆå¦‚ ZUCï¼‰é€‚åˆå®æ—¶æµæ•°æ®åŠ å¯†ï¼Œé€Ÿåº¦å¿«ä½†çŠ¶æ€ç®¡ç†å¤æ‚ï¼›åˆ†ç»„å¯†ç ï¼ˆå¦‚ SM4ï¼‰é€‚åˆå—æ•°æ®åŠ å¯†ï¼Œä½¿ç”¨æ›´çµæ´»ã€‚é€‰æ‹©æ—¶åº”æ ¹æ®å…·ä½“åº”ç”¨åœºæ™¯å†³å®šã€‚
:::

## å¿«é€Ÿå¼€å§‹

### åŸºæœ¬åŠ å¯†è§£å¯†

```typescript
import { zucEncrypt, zucDecrypt } from 'gmkitx';

// å¯†é’¥å’Œåˆå§‹åŒ–å‘é‡ï¼ˆå„ 128 ä½ï¼‰
const key = '0123456789abcdeffedcba9876543210'; // 32 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦
const iv = 'fedcba98765432100123456789abcdef';  // 32 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦

// åŠ å¯†
const plaintext = 'Hello, ZUC!';
const ciphertext = zucEncrypt(key, iv, plaintext);

// è§£å¯†ï¼ˆZUC æ˜¯æµå¯†ç ï¼ŒåŠ å¯†å’Œè§£å¯†ä½¿ç”¨ç›¸åŒæ“ä½œï¼‰
const decrypted = zucDecrypt(key, iv, ciphertext);
console.log(decrypted === plaintext); // true
```

### ä½¿ç”¨å‘½åç©ºé—´

```typescript
import { zuc } from 'gmkitx';

const key = '0123456789abcdeffedcba9876543210';
const iv = 'fedcba98765432100123456789abcdef';

const ciphertext = zuc.encrypt(key, iv, 'Hello, ZUC!');
const plaintext = zuc.decrypt(key, iv, ciphertext);
```

##  åŠ å¯†ç®—æ³•ï¼ˆ128-EEA3ï¼‰

ZUC æ˜¯åŒæ­¥æµå¯†ç ï¼Œé€šè¿‡ç”Ÿæˆå¯†é’¥æµä¸æ˜æ–‡å¼‚æˆ–å®ç°åŠ å¯†ã€‚

### å‡½æ•°å¼ API

```typescript
import { zucEncrypt, zucDecrypt } from 'gmkitx';

const key = '0123456789abcdeffedcba9876543210';
const iv = 'fedcba98765432100123456789abcdef';
const plaintext = 'Confidential Message';

// åŠ å¯†
const ciphertext = zucEncrypt(key, iv, plaintext);

// è§£å¯†ï¼ˆå¯¹å¯†æ–‡æ‰§è¡Œç›¸åŒæ“ä½œå³å¯è§£å¯†ï¼‰
const decrypted = zucDecrypt(key, iv, ciphertext);
```

### é¢å‘å¯¹è±¡ API

```typescript
import { ZUC } from 'gmkitx';

const key = '0123456789abcdeffedcba9876543210';
const iv = 'fedcba98765432100123456789abcdef';

// åˆ›å»º ZUC å®ä¾‹
const zuc = new ZUC(key, iv);

// åŠ å¯†
const ciphertext = zuc.encrypt('Hello, ZUC!');

// éœ€è¦é‡æ–°åˆå§‹åŒ–å®ä¾‹æ‰èƒ½è§£å¯†
const zucDecryptor = new ZUC(key, iv);
const plaintext = zucDecryptor.decrypt(ciphertext);
```

### å¤šç§è¾“å…¥è¾“å‡ºæ ¼å¼

```typescript
import { zucEncrypt, OutputFormat } from 'gmkitx';

// è¾“å…¥å­—ç¬¦ä¸²ï¼Œè¾“å‡ºåå…­è¿›åˆ¶ï¼ˆé»˜è®¤ï¼‰
const hexCipher = zucEncrypt(key, iv, 'Hello', {
  outputFormat: OutputFormat.HEX
});

// è¾“å…¥å­—ç¬¦ä¸²ï¼Œè¾“å‡º Base64
const base64Cipher = zucEncrypt(key, iv, 'Hello', {
  outputFormat: OutputFormat.BASE64
});

// è¾“å…¥å­—ç¬¦ä¸²ï¼Œè¾“å‡ºå­—èŠ‚æ•°ç»„
const bytesCipher = zucEncrypt(key, iv, 'Hello', {
  outputFormat: OutputFormat.BYTES
});

// è¾“å…¥å­—èŠ‚æ•°ç»„
const bytesInput = new Uint8Array([72, 101, 108, 108, 111]);
const encrypted = zucEncrypt(key, iv, bytesInput);
```

## ğŸ”’ å®Œæ•´æ€§ç®—æ³•ï¼ˆ128-EIA3ï¼‰

ZUC è¿˜æä¾›æ¶ˆæ¯è®¤è¯ç ï¼ˆMACï¼‰åŠŸèƒ½ï¼Œç”¨äºéªŒè¯æ•°æ®å®Œæ•´æ€§ã€‚

### ç”Ÿæˆ MAC

```typescript
import { zucMac } from 'gmkitx';

const key = '0123456789abcdeffedcba9876543210';
const iv = 'fedcba98765432100123456789abcdef';
const message = 'Important Message';

// ç”Ÿæˆ 32 ä½ MAC
const mac = zucMac(key, iv, message);
console.log('MAC:', mac); // 8 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦
```

### éªŒè¯ MAC

```typescript
import { zucMac } from 'gmkitx';

// å‘é€æ–¹
const key = '0123456789abcdeffedcba9876543210';
const iv = 'fedcba98765432100123456789abcdef';
const message = 'Important Message';
const mac = zucMac(key, iv, message);

// å°† message å’Œ mac å‘é€ç»™æ¥æ”¶æ–¹...

// æ¥æ”¶æ–¹
const receivedMessage = 'Important Message';
const receivedMac = mac;
const calculatedMac = zucMac(key, iv, receivedMessage);

if (calculatedMac === receivedMac) {
  console.log('âœ… æ¶ˆæ¯å®Œæ•´ï¼Œæœªè¢«ç¯¡æ”¹');
} else {
  console.log('âŒ æ¶ˆæ¯å·²è¢«ç¯¡æ”¹ï¼');
}
```

## ğŸ”‘ å¯†é’¥æµç”Ÿæˆ

ZUC çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯ç”Ÿæˆå¯†é’¥æµï¼ŒåŠ å¯†åªæ˜¯å°†å¯†é’¥æµä¸æ˜æ–‡å¼‚æˆ–ã€‚

### ç”ŸæˆæŒ‡å®šé•¿åº¦çš„å¯†é’¥æµ

```typescript
import { zucKeystream } from 'gmkitx';

const key = '0123456789abcdeffedcba9876543210';
const iv = 'fedcba98765432100123456789abcdef';

// ç”Ÿæˆ 16 å­—èŠ‚ï¼ˆ128 ä½ï¼‰çš„å¯†é’¥æµ
const keystream = zucKeystream(key, iv, 16);
console.log('å¯†é’¥æµ:', keystream); // 32 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦

// æ‰‹åŠ¨å¼‚æˆ–å®ç°åŠ å¯†
function manualEncrypt(plaintext: string, key: string, iv: string): string {
  const plaintextBytes = new TextEncoder().encode(plaintext);
  const keystreamBytes = hexToBytes(zucKeystream(key, iv, plaintextBytes.length));
  
  const cipherBytes = new Uint8Array(plaintextBytes.length);
  for (let i = 0; i < plaintextBytes.length; i++) {
    cipherBytes[i] = plaintextBytes[i] ^ keystreamBytes[i];
  }
  
  return bytesToHex(cipherBytes);
}
```

##  å®Œæ•´ API å‚è€ƒ

### åŠ å¯†è§£å¯†

| å‡½æ•° | è¯´æ˜ | è¿”å›å€¼ |
|------|------|--------|
| `zucEncrypt(key, iv, plaintext, options?)` | ZUC åŠ å¯† | `string \| Uint8Array` |
| `zucDecrypt(key, iv, ciphertext, options?)` | ZUC è§£å¯† | `string \| Uint8Array` |

### å®Œæ•´æ€§ä¿æŠ¤

| å‡½æ•° | è¯´æ˜ | è¿”å›å€¼ |
|------|------|--------|
| `zucMac(key, iv, message, options?)` | ç”Ÿæˆ MACï¼ˆ32 ä½ï¼‰ | `string` |

### å¯†é’¥æµç”Ÿæˆ

| å‡½æ•° | è¯´æ˜ | è¿”å›å€¼ |
|------|------|--------|
| `zucKeystream(key, iv, length)` | ç”ŸæˆæŒ‡å®šé•¿åº¦çš„å¯†é’¥æµ | `string` |

### ç±» API

| æ–¹æ³• | è¯´æ˜ | è¿”å›å€¼ |
|------|------|--------|
| `new ZUC(key, iv)` | åˆ›å»º ZUC å®ä¾‹ | `ZUC` |
| `encrypt(plaintext, options?)` | åŠ å¯† | `string \| Uint8Array` |
| `decrypt(ciphertext, options?)` | è§£å¯† | `string \| Uint8Array` |
| `generateKeystream(length)` | ç”Ÿæˆå¯†é’¥æµ | `Uint8Array` |

### é€‰é¡¹å‚æ•°

```typescript
interface ZUCOptions {
  outputFormat?: 'hex' | 'base64' | 'bytes';  // è¾“å‡ºæ ¼å¼
}
```

##  ä½¿ç”¨åœºæ™¯

### 1. ç§»åŠ¨é€šä¿¡åŠ å¯†ï¼ˆ4G/5Gï¼‰

```typescript
import { zucEncrypt, zucDecrypt } from 'gmkitx';

// æ¨¡æ‹Ÿ LTE æ•°æ®åŠ å¯†
class LTECipher {
  private readonly key: string;
  
  constructor(k: string) {
    this.key = k;
  }
  
  // åŠ å¯†ä¸Šè¡Œæ•°æ®
  encryptUplink(data: string, count: number, bearer: number): string {
    const iv = this.generateIV(count, bearer, 0); // 0 = uplink
    return zucEncrypt(this.key, iv, data);
  }
  
  // åŠ å¯†ä¸‹è¡Œæ•°æ®
  encryptDownlink(data: string, count: number, bearer: number): string {
    const iv = this.generateIV(count, bearer, 1); // 1 = downlink
    return zucEncrypt(this.key, iv, data);
  }
  
  // æ ¹æ® 3GPP æ ‡å‡†ç”Ÿæˆ IV
  private generateIV(count: number, bearer: number, direction: number): string {
    // IV = COUNT || BEARER || DIRECTION || 0...0
    const countHex = count.toString(16).padStart(8, '0');
    const bearerBits = (bearer << 27) | (direction << 26);
    const ivSuffix = bearerBits.toString(16).padStart(24, '0');
    return countHex + ivSuffix;
  }
}
```

### 2. æ•°æ®æµåŠ å¯†

```typescript
import { ZUC } from 'gmkitx';

// æµå¼æ•°æ®åŠ å¯†
class StreamCipher {
  private zuc: ZUC;
  
  constructor(key: string, iv: string) {
    this.zuc = new ZUC(key, iv);
  }
  
  // åŠ å¯†æ•°æ®æµ
  encryptStream(dataChunks: string[]): string[] {
    return dataChunks.map(chunk => this.zuc.encrypt(chunk));
  }
  
  // å®æ—¶è§†é¢‘æµåŠ å¯†
  encryptVideoFrame(frame: Uint8Array): Uint8Array {
    return this.zuc.encrypt(frame, {
      outputFormat: OutputFormat.BYTES
    }) as Uint8Array;
  }
}
```

### 3. æ¶ˆæ¯å®Œæ•´æ€§ä¿æŠ¤

```typescript
import { zucEncrypt, zucMac } from 'gmkitx';

// åŒæ—¶æä¾›åŠ å¯†å’Œå®Œæ•´æ€§ä¿æŠ¤
class SecureMessage {
  static send(key: string, message: string) {
    const encIV = generateRandomIV();
    const macIV = generateRandomIV();
    
    // åŠ å¯†æ¶ˆæ¯
    const ciphertext = zucEncrypt(key, encIV, message);
    
    // ç”Ÿæˆ MAC
    const mac = zucMac(key, macIV, ciphertext);
    
    return { ciphertext, mac, encIV, macIV };
  }
  
  static receive(key: string, packet: any): string | null {
    const { ciphertext, mac, encIV, macIV } = packet;
    
    // éªŒè¯ MAC
    const calculatedMac = zucMac(key, macIV, ciphertext);
    if (calculatedMac !== mac) {
      console.error('MAC éªŒè¯å¤±è´¥ï¼Œæ¶ˆæ¯å¯èƒ½è¢«ç¯¡æ”¹');
      return null;
    }
    
    // è§£å¯†æ¶ˆæ¯
    return zucDecrypt(key, encIV, ciphertext);
  }
}

// ä½¿ç”¨
const key = '0123456789abcdeffedcba9876543210';
const packet = SecureMessage.send(key, 'Secret Message');
const decrypted = SecureMessage.receive(key, packet);
```

### 4. IoT è®¾å¤‡é€šä¿¡

```typescript
import { zucEncrypt, zucDecrypt } from 'gmkitx';

// IoT è®¾å¤‡é—´åŠ å¯†é€šä¿¡
class IoTDevice {
  private readonly deviceKey: string;
  private counter: number = 0;
  
  constructor(deviceId: string, masterKey: string) {
    // ä»ä¸»å¯†é’¥æ´¾ç”Ÿè®¾å¤‡å¯†é’¥
    this.deviceKey = this.deriveDeviceKey(deviceId, masterKey);
  }
  
  // å‘é€åŠ å¯†æ¶ˆæ¯
  sendMessage(data: any, targetDevice: string): string {
    const message = JSON.stringify(data);
    const iv = this.generateIV(this.counter++);
    
    return zucEncrypt(this.deviceKey, iv, message);
  }
  
  // æ¥æ”¶åŠ å¯†æ¶ˆæ¯
  receiveMessage(encrypted: string, counter: number): any {
    const iv = this.generateIV(counter);
    const decrypted = zucDecrypt(this.deviceKey, iv, encrypted);
    
    return JSON.parse(decrypted);
  }
  
  private deriveDeviceKey(deviceId: string, masterKey: string): string {
    // ç®€å•çš„å¯†é’¥æ´¾ç”Ÿï¼ˆå®é™…åº”ä½¿ç”¨ KDFï¼‰
    return sm3Digest(masterKey + deviceId).substring(0, 32);
  }
  
  private generateIV(counter: number): string {
    // ä½¿ç”¨è®¡æ•°å™¨ä½œä¸º IV çš„ä¸€éƒ¨åˆ†
    return counter.toString(16).padStart(32, '0');
  }
}
```

### 5. æ–‡ä»¶åŠ å¯†

```typescript
import { zucEncrypt, zucDecrypt } from 'gmkitx';
import { readFileSync, writeFileSync } from 'fs';

// æ–‡ä»¶åŠ å¯†å·¥å…·
class FileEncryptor {
  static encryptFile(
    inputPath: string,
    outputPath: string,
    key: string
  ): void {
    const data = readFileSync(inputPath);
    const iv = generateRandomIV();
    
    // åŠ å¯†æ–‡ä»¶å†…å®¹
    const encrypted = zucEncrypt(key, iv, data, {
      outputFormat: OutputFormat.BASE64
    });
    
    // ä¿å­˜ IV å’Œå¯†æ–‡
    const output = JSON.stringify({ iv, encrypted });
    writeFileSync(outputPath, output);
  }
  
  static decryptFile(
    inputPath: string,
    outputPath: string,
    key: string
  ): void {
    const input = JSON.parse(readFileSync(inputPath, 'utf-8'));
    const { iv, encrypted } = input;
    
    // è§£å¯†æ–‡ä»¶å†…å®¹
    const decrypted = zucDecrypt(key, iv, encrypted);
    writeFileSync(outputPath, decrypted);
  }
}

// ä½¿ç”¨
const key = '0123456789abcdeffedcba9876543210';
FileEncryptor.encryptFile('document.pdf', 'document.enc', key);
FileEncryptor.decryptFile('document.enc', 'document_decrypted.pdf', key);
```

##  é«˜çº§ç”¨æ³•

### å¯†é’¥æ´¾ç”Ÿ

```typescript
import { sm3Digest } from 'gmkitx';

// ä»ä¸»å¯†é’¥æ´¾ç”Ÿä¼šè¯å¯†é’¥
function deriveSessionKey(
  masterKey: string,
  sessionId: string,
  timestamp: number
): string {
  const data = `${masterKey}:${sessionId}:${timestamp}`;
  const hash = sm3Digest(data);
  return hash.substring(0, 32); // 128 ä½å¯†é’¥
}

// ä½¿ç”¨
const masterKey = 'master-secret-key';
const sessionKey = deriveSessionKey(masterKey, 'session-123', Date.now());
```

### IV ç®¡ç†

```typescript
import { randomBytes } from 'crypto';

// ç”Ÿæˆéšæœº IV
function generateRandomIV(): string {
  return randomBytes(16).toString('hex');
}

// ä»åºåˆ—å·ç”Ÿæˆ IVï¼ˆç”¨äºæœ‰åºæ¶ˆæ¯ï¼‰
function generateSequentialIV(sequenceNumber: number): string {
  return sequenceNumber.toString(16).padStart(32, '0');
}

// ä»æ—¶é—´æˆ³ç”Ÿæˆ IV
function generateTimestampIV(timestamp: number): string {
  const timestampHex = timestamp.toString(16).padStart(16, '0');
  const randomHex = randomBytes(8).toString('hex');
  return timestampHex + randomHex;
}
```

### æ‰¹é‡åŠ å¯†

```typescript
import { zucEncrypt } from 'gmkitx';

// æ‰¹é‡åŠ å¯†å¤šæ¡æ¶ˆæ¯
function encryptBatch(
  messages: string[],
  key: string
): Array<{ ciphertext: string; iv: string }> {
  return messages.map(message => {
    const iv = generateRandomIV();
    const ciphertext = zucEncrypt(key, iv, message);
    return { ciphertext, iv };
  });
}

// ä½¿ç”¨
const key = '0123456789abcdeffedcba9876543210';
const messages = ['msg1', 'msg2', 'msg3'];
const encrypted = encryptBatch(messages, key);
```

##  æ³¨æ„äº‹é¡¹

1. **å¯†é’¥é•¿åº¦**: ZUC å¯†é’¥å¿…é¡»æ˜¯ 128 ä½ï¼ˆ32 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
2. **IV é•¿åº¦**: åˆå§‹åŒ–å‘é‡å¿…é¡»æ˜¯ 128 ä½ï¼ˆ32 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
3. **IV å”¯ä¸€æ€§**: 
   - å¯¹äºåŒä¸€ä¸ªå¯†é’¥ï¼Œç»å¯¹ä¸èƒ½é‡å¤ä½¿ç”¨ç›¸åŒçš„ IV
   - IV é‡å¤ä½¿ç”¨ä¼šå¯¼è‡´ä¸¥é‡çš„å®‰å…¨æ¼æ´
4. **æµå¯†ç ç‰¹æ€§**: 
   - ZUC æ˜¯æµå¯†ç ï¼ŒåŠ å¯†å’Œè§£å¯†æ“ä½œç›¸åŒ
   - å¿…é¡»ä½¿ç”¨ç›¸åŒçš„å¯†é’¥å’Œ IV æ‰èƒ½æ­£ç¡®è§£å¯†
5. **åŒæ­¥æ€§**: ZUC æ˜¯åŒæ­¥æµå¯†ç ï¼Œå¿…é¡»ä»å¤´å¼€å§‹å¤„ç†æ•°æ®
6. **å¯†é’¥ä¿å¯†**: å¯†é’¥å¿…é¡»å¦¥å–„ä¿ç®¡ï¼Œæ³„éœ²å°†å¯¼è‡´æ‰€æœ‰åŠ å¯†æ•°æ®ä¸å®‰å…¨
7. **å®Œæ•´æ€§**: ZUC åŠ å¯†ä¸æä¾›å®Œæ•´æ€§ä¿æŠ¤ï¼Œåº”é…åˆ MAC ä½¿ç”¨
8. **çŠ¶æ€ç®¡ç†**: ä½¿ç”¨ç±» API æ—¶ï¼ŒåŠ å¯†åå®ä¾‹çŠ¶æ€å·²æ”¹å˜ï¼Œä¸èƒ½ç›´æ¥ç”¨äºè§£å¯†

##  å¸¸è§é—®é¢˜

### Q: ZUC å’Œ SM4 æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: 
- **ZUC** æ˜¯æµå¯†ç ï¼Œé€å­—èŠ‚åŠ å¯†ï¼Œä¸éœ€è¦å¡«å……ï¼Œé€Ÿåº¦å¿«
- **SM4** æ˜¯åˆ†ç»„å¯†ç ï¼ŒæŒ‰ 16 å­—èŠ‚å—åŠ å¯†ï¼Œéœ€è¦å¡«å……
- ZUC æ›´é€‚åˆå®æ—¶æ•°æ®æµï¼ŒSM4 æ›´é€‚åˆæ‰¹é‡æ•°æ®
- ZUC ä¸»è¦ç”¨äºç§»åŠ¨é€šä¿¡ï¼ŒSM4 ç”¨é€”æ›´å¹¿æ³›

### Q: ä¸ºä»€ä¹ˆ IV ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Ÿ

A: ZUC æ˜¯æµå¯†ç ï¼Œç›¸åŒçš„å¯†é’¥å’Œ IV ä¼šäº§ç”Ÿç›¸åŒçš„å¯†é’¥æµã€‚å¦‚æœé‡å¤ä½¿ç”¨ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡åˆ†æä¸¤ä¸ªå¯†æ–‡çš„å¼‚æˆ–å€¼æ¥æ¨æ–­æ˜æ–‡ã€‚è¿™æ˜¯æµå¯†ç çš„å¸¸è§æ¼æ´ã€‚

### Q: ZUC çš„ MAC åŠŸèƒ½å’Œ SM3 å“ˆå¸Œæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: 
- ZUC MAC éœ€è¦å¯†é’¥ï¼Œåªæœ‰æŒæœ‰å¯†é’¥çš„äººæ‰èƒ½ç”Ÿæˆå’ŒéªŒè¯
- SM3 æ˜¯å…¬å¼€å“ˆå¸Œï¼Œä»»ä½•äººéƒ½èƒ½è®¡ç®—
- ZUC MAC ç”¨äºå®Œæ•´æ€§ä¿æŠ¤å’Œè®¤è¯
- SM3 ç”¨äºæ•°æ®æ‘˜è¦å’Œå®Œæ•´æ€§æ ¡éªŒ

### Q: å¯ä»¥ç”¨ ZUC åŠ å¯†å¤§æ–‡ä»¶å—ï¼Ÿ

A: å¯ä»¥ï¼Œä½†éœ€è¦æ³¨æ„ï¼š
- ZUC æ˜¯æµå¯†ç ï¼Œç†è®ºä¸Šå¯ä»¥åŠ å¯†ä»»æ„é•¿åº¦çš„æ•°æ®
- å®é™…åº”ç”¨ä¸­ï¼Œåº”åˆ†å—å¤„ç†å¤§æ–‡ä»¶
- æ¯ä¸ªæ–‡ä»¶æˆ–ä¼šè¯åº”ä½¿ç”¨ä¸åŒçš„ IV

### Q: ZUC åœ¨ 4G/5G ä¸­å¦‚ä½•ä½¿ç”¨ï¼Ÿ

A: ZUC ä½œä¸º 128-EEA3 å’Œ 128-EIA3 ç®—æ³•åœ¨ LTE/5G ä¸­ä½¿ç”¨ï¼š
- 128-EEA3ï¼šç”¨äºç”¨æˆ·æ•°æ®å’Œä¿¡ä»¤çš„åŠ å¯†
- 128-EIA3ï¼šç”¨äºä¿¡ä»¤çš„å®Œæ•´æ€§ä¿æŠ¤
- IV ç”±å¸§åºå·ã€æ— çº¿æ‰¿è½½æ ‡è¯†å’Œæ–¹å‘ç»„æˆ

##  æ€§èƒ½ç‰¹ç‚¹

### ä¼˜åŠ¿

- âœ… æµå¯†ç è®¾è®¡ï¼ŒåŠ å¯†é€Ÿåº¦å¿«
- âœ… ä¸éœ€è¦å¡«å……ï¼Œé€‚åˆä»»æ„é•¿åº¦æ•°æ®
- âœ… å†…å­˜å ç”¨å°
- âœ… é€‚åˆç¡¬ä»¶å®ç°
- âœ… å»¶è¿Ÿä½ï¼Œé€‚åˆå®æ—¶é€šä¿¡

### æ€§èƒ½åŸºå‡†

åœ¨ç°ä»£ç¡¬ä»¶ä¸Šçš„æ€§èƒ½å‚è€ƒï¼š

| æ“ä½œ | ååé‡ |
|------|--------|
| å¯†é’¥æµç”Ÿæˆ | ~500 MB/s |
| åŠ å¯†/è§£å¯† | ~400 MB/s |
| MAC ç”Ÿæˆ | ~300 MB/s |

> æ³¨: å®é™…æ€§èƒ½å–å†³äºç¡¬ä»¶é…ç½®å’Œè¿è¡Œç¯å¢ƒ

##  ç›¸å…³èµ„æº

- [GM/T 0001-2012 ZUC æ ‡å‡†](http://www.gmbz.org.cn/)
- [3GPP TS 35.221 - 128-EEA3](https://www.3gpp.org/DynaReport/35221.htm)
- [3GPP TS 35.222 - 128-EIA3](https://www.3gpp.org/DynaReport/35222.htm)
- [æµå¯†ç åŸºç¡€](https://en.wikipedia.org/wiki/Stream_cipher)

##  ç›¸å…³ç®—æ³•

- [SM2 - æ¤­åœ†æ›²çº¿å…¬é’¥å¯†ç ç®—æ³•](./SM2.md)
- [SM3 - å¯†ç æ‚å‡‘ç®—æ³•](./SM3.md)
- [SM4 - åˆ†ç»„å¯†ç ç®—æ³•](./SM4.md)
